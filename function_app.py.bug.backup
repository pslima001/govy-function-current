import sys
import os
import json
import traceback
import re
import azure.functions as func

ROOT = os.path.dirname(os.path.abspath(__file__))
sys.path.insert(0, ROOT)

app = func.FunctionApp()

@app.function_name(name="ping")
@app.route(route="ping", methods=["GET"], auth_level=func.AuthLevel.ANONYMOUS)
def ping(req: func.HttpRequest) -> func.HttpResponse:
    return func.HttpResponse("pong", status_code=200)


@app.function_name(name="extract_params")
@app.route(route="extract_params", methods=["POST"], auth_level=func.AuthLevel.FUNCTION)
def extract_params(req: func.HttpRequest) -> func.HttpResponse:
    """
    Handler REAL para extração de parâmetros de editais.
    Implementado por ChatGPT 5.2 - 14/01/2026
    """
    try:
        # Imports dentro da função (conforme especificado)
        from azure.storage.blob import BlobServiceClient
        from azure.ai.documentintelligence import DocumentIntelligenceClient
        from azure.core.credentials import AzureKeyCredential

        # =========================
        # 1. Validar request
        # =========================
        try:
            body = req.get_json()
        except Exception:
            body = None

        blob_name = body.get("blob_name") if isinstance(body, dict) else None
        if not blob_name:
            return func.HttpResponse(
                json.dumps({
                    "status": "error",
                    "error": "blob_name is required",
                    "blob_name": None
                }),
                status_code=400,
                mimetype="application/json"
            )

        # =========================
        # 2. Download do PDF
        # =========================
        conn_str = os.getenv("AZURE_STORAGE_CONNECTION_STRING")
        container_name = os.getenv("BLOB_CONTAINER_NAME", "editais-teste")

        if not conn_str:
            raise RuntimeError("AZURE_STORAGE_CONNECTION_STRING not set")

        blob_service = BlobServiceClient.from_connection_string(conn_str)
        container_client = blob_service.get_container_client(container_name)
        blob_client = container_client.get_blob_client(blob_name)

        try:
            pdf_bytes = blob_client.download_blob().readall()
        except Exception:
            return func.HttpResponse(
                json.dumps({
                    "status": "error",
                    "error": f"Blob not found: {blob_name}",
                    "blob_name": blob_name
                }),
                status_code=404,
                mimetype="application/json"
            )

        # =========================
        # 3. Extração de texto (Document Intelligence)
        # =========================
        di_endpoint = os.getenv("DOCUMENT_INTELLIGENCE_ENDPOINT")
        di_key = os.getenv("DOCUMENT_INTELLIGENCE_KEY")

        if not di_endpoint or not di_key:
            raise RuntimeError("DOCUMENT_INTELLIGENCE_ENDPOINT or KEY not set")

        di_client = DocumentIntelligenceClient(
            endpoint=di_endpoint,
            credential=AzureKeyCredential(di_key)
        )

        poller = di_client.begin_analyze_document(
            "prebuilt-read",
            pdf_bytes
        )
        result = poller.result(timeout=180)

        texto = result.content or ""
        if isinstance(texto, bytes):
            texto = texto.decode("utf-8", errors="ignore")
        
        # DEBUG: Salvar primeiras 2000 caracteres do texto extraído
        import logging
        logging.warning(f"TEXTO EXTRAIDO (primeiros 2000 chars): {texto[:2000]}")

        # =========================
        # 4. Carregar patterns.json
        # =========================
        patterns_path = os.path.join(ROOT, "patterns.json")

        with open(patterns_path, "r", encoding="utf-8") as f:
            patterns = json.load(f)

        # =========================
        # 5. Função de extração genérica
        # =========================
        def extrair_parametro(texto: str, config: dict) -> dict:
            score = 0.0
            melhor_match = None
            melhor_contexto = None

            texto_lower = texto.lower()

            # Termos positivos
            for termo in config.get("termos_positivos", []):
                if termo.lower() in texto_lower:
                    score += config.get("peso_contexto_positivo", 0)

            # Termos negativos
            for termo in config.get("termos_negativos", []):
                if termo.lower() in texto_lower:
                    score += config.get("peso_contexto_negativo", 0)

            # Regex patterns
            for pattern in config.get("regex_patterns", []):
                for match in re.finditer(pattern, texto, re.IGNORECASE):
                    valor = match.group(1) if match.lastindex else match.group(0)

                    start = max(0, match.start() - 30)
                    end = min(len(texto), match.end() + 30)
                    contexto = texto[start:end].strip()

                    if len(contexto) > 200:
                        contexto = contexto[:200] + "..."

                    score_local = score

                    # Sinônimos
                    for _, sinonimos in config.get("sinonimos", {}).items():
                        for s in sinonimos:
                            if s.lower() in contexto.lower():
                                score_local += config.get("peso_sinonimo", 0)

                    if melhor_match is None or score_local > score:
                        melhor_match = valor
                        melhor_contexto = contexto
                        score = score_local

            confianca = min(1.0, max(0.0, score / 10.0))

            return {
                "encontrado": melhor_match is not None,
                "valor": melhor_match,
                "confianca": confianca,
                "contexto": melhor_contexto
            }

        # =========================
        # 6. Aplicar extractors
        # =========================
        parametros = {}
        for pid in ["e001", "pg001", "o001", "l001"]:
            cfg = patterns.get(pid)
            if not cfg:
                parametros[pid] = {
                    "encontrado": False,
                    "valor": None,
                    "confianca": 0.0,
                    "contexto": None
                }
            else:
                parametros[pid] = extrair_parametro(texto, cfg)

        # =========================
        # 7. Response final
        # =========================
        return func.HttpResponse(
            json.dumps({
                "status": "success",
                "blob_name": blob_name,
                "parametros": parametros
            }, ensure_ascii=False),
            status_code=200,
            mimetype="application/json"
        )

    except Exception as e:
        return func.HttpResponse(
            json.dumps({
                "status": "error",
                "error": str(e),
                "traceback": traceback.format_exc()
            }),
            status_code=500,
            mimetype="application/json"
        )


@app.function_name(name="parse_layout")
@app.route(route="parse_layout", methods=["POST"], auth_level=func.AuthLevel.FUNCTION)
def parse_layout(req: func.HttpRequest) -> func.HttpResponse:
    return func.HttpResponse(
        json.dumps({"status": "stub_ok", "function": "parse_layout"}),
        status_code=200,
        mimetype="application/json"
    )


@app.function_name(name="upload_edital")
@app.route(route="upload_edital", methods=["POST"], auth_level=func.AuthLevel.FUNCTION)
def upload_edital(req: func.HttpRequest) -> func.HttpResponse:
    return func.HttpResponse(
        json.dumps({"status": "stub_ok", "function": "upload_edital"}),
        status_code=200,
        mimetype="application/json"
    )